/**
 * Example Jenkinsfile using ML Node Selector
 * 
 * This pipeline demonstrates:
 * 1. ML-based node selection
 * 2. Building on the predicted node
 * 3. Collecting metrics for model training
 * 4. Comparing predicted vs actual usage
 */

@Library('ml-node-selector') _

pipeline {
    agent none  // Agent selected dynamically by ML
    
    parameters {
        choice(
            name: 'BUILD_TYPE',
            choices: ['debug', 'release'],
            description: 'Build type (release needs more resources)'
        )
    }
    
    environment {
        BUILD_ID = "${env.JOB_NAME}-${env.BUILD_NUMBER}"
    }
    
    stages {
        stage('ğŸ¤– ML Node Selection') {
            agent { label 'master' }  // Quick analysis on master
            steps {
                checkout scm
                
                script {
                    // Get ML prediction for optimal node
                    def prediction = selectNode(
                        buildType: params.BUILD_TYPE
                    )
                    
                    // Store results for display
                    env.SELECTED_LABEL = prediction.label
                    env.SELECTED_INSTANCE = prediction.instanceType
                    env.PREDICTED_MEMORY = prediction.predictedMemoryGb
                    env.PREDICTED_CPU = prediction.predictedCpu
                    env.PREDICTED_TIME = prediction.predictedTimeMinutes
                    
                    echo """
                    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                    â•‘       ML NODE SELECTION COMPLETE           â•‘
                    â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                    â•‘ Label:    ${prediction.label.padRight(30)}â•‘
                    â•‘ Instance: ${prediction.instanceType.padRight(30)}â•‘
                    â•‘ Memory:   ${prediction.predictedMemoryGb} GB${' '.multiply(24)}â•‘
                    â•‘ CPU:      ${prediction.predictedCpu}%${' '.multiply(26)}â•‘
                    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    """
                }
            }
        }
        
        stage('ğŸ—ï¸ Build') {
            agent { label "${env.ML_SELECTED_LABEL}" }  // Use ML-selected label!
            steps {
                checkout scm
                
                script {
                    // Start metrics collection for model training
                    collectBuildMetrics.start(
                        buildId: env.BUILD_ID
                    )
                    
                    echo "Building on ${env.SELECTED_INSTANCE} (${env.SELECTED_LABEL})"
                    
                    // ========================================
                    // YOUR ACTUAL BUILD STEPS GO HERE
                    // ========================================
                    
                    // Example: Gradle build
                    // sh './gradlew clean build'
                    
                    // Example: Maven build
                    // sh 'mvn clean package'
                    
                    // Example: npm build
                    // sh 'npm install && npm run build'
                    
                    // For demo, just sleep
                    echo "Simulating build..."
                    sleep(time: 30, unit: 'SECONDS')
                    
                    // ========================================
                    // END OF BUILD STEPS
                    // ========================================
                    
                    // Stop collection and get actual metrics
                    def actual = collectBuildMetrics.stop(
                        buildId: env.BUILD_ID,
                        status: 'SUCCESS',
                        buildType: params.BUILD_TYPE
                    )
                    
                    // Display comparison
                    echo """
                    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                    â•‘       PREDICTION vs ACTUAL                 â•‘
                    â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                    â•‘ Metric      â”‚ Predicted â”‚ Actual           â•‘
                    â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                    â•‘ Memory (GB) â”‚ ${env.PREDICTED_MEMORY.padRight(9)} â”‚ ${actual.memory.toString().padRight(18)}â•‘
                    â•‘ CPU (%)     â”‚ ${env.PREDICTED_CPU.padRight(9)} â”‚ ${actual.cpu.toString().padRight(18)}â•‘
                    â•‘ Time (min)  â”‚ ${env.PREDICTED_TIME.padRight(9)} â”‚ ${(actual.duration/60).round(1).toString().padRight(18)}â•‘
                    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    """
                }
            }
        }
    }
    
    post {
        always {
            echo "Build completed on ${env.SELECTED_LABEL} (${env.SELECTED_INSTANCE})"
        }
        success {
            echo "âœ… Build successful!"
        }
        failure {
            echo "âŒ Build failed!"
        }
    }
}
